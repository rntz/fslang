\documentclass[sigplan,screen,dvipsnames,fleqn]{acmart}
\settopmatter{printacmref=false}
\setcopyright{none}
\renewcommand\footnotetextcopyrightpermission[1]{}
%\pagestyle{plain}


%% ---- Top matter ----
\title{Finite functional programming via graded effects and relevance types}
\author{Michael Arntzenius}
\affiliation{%
  \institution{UC Berkeley}
  \city{Berkeley}
  \country{USA}
}
\email{daekharel@gmail.com}
\acmConference{Higher Order Programming with Effects}{12 October 2025}{Singapore}


%% ---- Packages ----
%\usepackage{anyfontsize} % silence font size not available warnings by autoscaling fonts
\usepackage{amsmath}
%\usepackage{latexsym,stmaryrd}
%\usepackage{mathtools}          % \dblcolon
\usepackage{mathpartir}         % mathpar
\usepackage{nccmath}            % fleqn (for code environment)

%% \usepackage{minted}
\usepackage{listings}           % lstlisting
\lstset{language=prolog, columns=fullflexible,
  basicstyle=\ttfamily, commentstyle=\color{Green}}

\usepackage{hyperref,url}
\usepackage[nameinlink,noabbrev]{cleveref}
\newcommand\crefrangeconjunction{--} % use en-dashes for ranges.


%% ---------- Code environment ----------
\newlength\codeoffset
\setlength\codeoffset{0pt}

\NewEnviron{code}{
  \begin{fleqn}[\codeoffset]
    \begin{flalign*}
      \setlength\arraycolsep{0pt} % necessary for flush left alignment.
      \begin{array}{l}\BODY\end{array}
  \end{flalign*}
  \end{fleqn}
}


%% ---------- \negphantom command ----------
%% https://tex.stackexchange.com/questions/316426/negative-phantom-inside-equations
\makeatletter
\newlength{\negph@wd}
\DeclareRobustCommand{\negphantom}[1]{%
  \ifmmode
    \mathpalette\negph@math{#1}%
  \else
    \negph@do{#1}%
  \fi
}
\newcommand{\negph@math}[2]{\negph@do{$\m@th#1#2$}}
\newcommand{\negph@do}[1]{%
  \settowidth{\negph@wd}{#1}%
  \hspace*{-\negph@wd}%
}\makeatother


%% ---- Commands ----
\newcommand{\todo}[1]{{\color{ACMRed}#1}}

\newcommand\bnfeq{\Coloneqq}
\newcommand\bnfor{\mathrel{\,|\,}}

\newcommand\name[1]{\ensuremath{\mathit{#1}}}
\newcommand\fnspace{\;}
\newcommand\fn[1]{\lambda{#1}.\fnspace}
\newcommand\<\;                 %function application space

\newcommand\cto{\Rightarrow}    % "cartesian \to"
\newcommand\lto\multimap        % "linear \to"
%\newcommand\fto{\underset{\textsf{fin}}{\to}}           % finite map
\newcommand\fto{\rightarrow}    % "finitely supported \to"
\newcommand\x\times
\newcommand\with{\mathbin{\&}}
\newcommand\ox\otimes
\newcommand\tbool{\name{bool}}
\newcommand\tmaybe[1]{\ensuremath{{#1}_{*}}}
\renewcommand\tmaybe[1]{\ensuremath{\name{maybe}１茴鬻泔眄犷滠躅溴螋疱鄄蓰荃钿弪徙沐铘荇屮趔纣荃痼栳疱荏泱栳疱１２茴鬻泔眄犷滠羼糅陛荃钿弪豉疱羼１茴鬻泔眄犷滠擒轻眄茴鬻泔眄犷滠能腻祠茯孱鬻泔眄犷滠宪享彗茯孱鬻泔眄犷滠誊提礅溽ボ铄縻镯磲钿苠眇豉泺荟狎屦箝祜茴鬻泔眄犷滠屙痿泺茔滹酏茴鬻泔眄犷滠镦茼狒桠轭糊茴鬻泔眄犷滠泺箦瘥茼狒桠轭茴鬻泔眄犷滠棂疔草１茱２茴鬻泔眄犷滠闶鄢蓰３墁荟溽箬墁１２茴鬻泔眄犷滠售递３茔箦４茔箦５墁荟溽箬墁１２ボ铄縻镯磲钿莛售递３茔箦４茔箦１２墁荟溽箬墁５茴鬻泔眄犷滠泔铙糗钺礤茴鬻泔眄犷滠泐犴遘翦ャ镱篝蝓泗矧钺礤茴鬻泔眄犷滠泐殪茔钺礤铋忑茴鬻泔眄犷滠汴躞酐茔钺礤牾篝茴鬻泔眄犷滠泗蝓妍茔钺礤趄蹂茴鬻泔眄犷滠沔犰箦茔钺礤驷祗妪茴鬻泔眄犷滠纛殪茔铋茴鬻泔眄犷滠絷躞糅陛茔牾篝芗１茴鬻泔眄犷滠戾糸钲草荇屮翕纣戾酏１荇屮翕纣轭２茴鬻泔眄犷滠戾翦褊齿莒弭轭１２３茴鬻泔眄犷滠戾絷躞糅齿莒弭羼荇牾篝１２３茴鬻泔眄犷滠戾麴衢蜊摧莒弭羼１２３４茴鬻泔眄犷滠趑蝓妍茔趄蹂茴鬻泔眄犷滠翩犰箦茔驷祗妪茴鬻泔眄犷滠翎怏躜潲茴犴妍徕篚蜾芗茴鬻泔眄犷滠翎钿茼狒栩屐茼狒桠纣犷潺茴鬻泔眄犷滠麸螓茼狒栩屐茼狒桠纣矧茆彗轭滹沲礤铘茆彗轭徕篝蜥泗痱镳矬躅殒轭骢钽糸镱犰犷祜玳惘蝈灬糸镱犰痱镧蜥眄轭怡趄遽糸铉痱邃殂狒弩蝈灬糸镱狍骢钽糸镱羼蹰痧邃鏖翳翳彘篚痧矧翳箦镦轭瘐趔麒矬秕麴豸轶铒瞽驷祗瀹骑轭篝犷沐翳祜玳痱镧蜥眄轭灬铉踽珏尼翎祜绗轭麒殂犰蝈灬糸镱狎骈铋翦轶灬铉踽珏镦骈铋翦禊篚痧矧翦怙镬遽骢钽糸镱螽崎铋翦篚痧矧犰祜黧蝈痱弩孱糸铉翳骢钽糸镱铒狍泔溴怩狍溽翎狍翎忪镦轭瘐舡秕麴豸疳轵磲腴铉怩祀镳弪狒轱铙盹蝈彐骈汩孱舢涉麇泔礅轭骈铋翦禊篚痧矧翦骢钽糸镱蟋蝈痱弩孱翦狍溽翎犷栝玷弪矧溴骢钽糸镱蟋蝈痱弩孱翦狍泔溴轭翳筢礤灬铉踽珏麇珏麒狒汜祆苠眇棼骈铋翦骢钽糸镱犰痱镧蜥眄轭绠燥翳轶孱洮溴盹铙趄狒箝眇戾豉疱簌篝屙麸汨邈骈铋翦篚痧矧怡趄遽糸铉鲠蜷徕戾珧秕钿轭狍ㄣ铹彐驽泗チ珑蝈玑糸镱犷雉桢尼翎祜屮翦铙轱铙篚汨狍忉犷箦黹蜷铉箦磲铘殂螬狎钺趱蜥祆栳钿戾怡珏铄蜥扉轭骝镯怙镬遽骢钽糸镱麸狎忾趄狎痫轭翦秕麴豸豉疱螽ゥ荇镤稃滹徙趱犰禊滹翳轶ぼ蜷玷翎蝌秣ゥ箅弭汨骢趱蝈黠螂镱箦磲铘殂犷轫痨屙孱翎糸镱篝蜥翦玳弩疳螋殂蹯狎禊骘蝈沲蝮轱町苠钿徕篝蜥泗茼犭弭轸戾ゥ荏邈糸镱惋糸鲠糸镱ゥ蕊滹麇豉疱翳轶蛮趄遽糸铉鲠蜷徕戾珧秕钿轭狍犷噱骀邈衄镦箫螋螽矧轶轸泔彐驽泗ゥ轭翦珧狒轭蝈灬糸镱犰犷骢钽糸镱犰痱镧蜥眄轭缁尼翎祜轭翳灬蜱寤盹漉灬犷栝玷弪矧溴泔溴ゥ屮疳钿轭尼翎祜麸脲鲠祯磲痼彗箦黹灬趑殂箦磲铘殂蟋箦黹蜷铉箦磲铘殂螽ゥ磲腴铉轸盹蝈钺趱蜥麸黩轸徵珧彗狒轱铙弭惝ゥ痱镳矬麸翳轭镦祜玳痱镧蜥眄轭狍忮轭徕秕衄铒噜蝈灬糸镱螫К怩苠眇棼骢钽糸镱簖蝈灬糸镱轶蝈犰禊骢钽糸镱轭麸怙镬遽铙镱沐麇翎脲翳轶痫轭镦鲩鬻脲鲠祯磲痼狎犷镡鲩秕珏铄蜥扉狒轱町ゥ麒狒箴邈獒徕秕蝈灬糸镱犰痱镧蜥眄轭泔眇狎邃鏖翳骢钽糸镱犰痱镧蜥眄轭轶翳狒骢钽糸镱狎苠眇棼铒酏趄遽翦狍忪徙氕怙轭瘐舡秕麴豸趄犷箧矧磲糸镱蟋怩汜犰箫忮蝓噜忉汶麽蜾螫М轭疳螋殂蹯狎麇汜聃弪翳苠眇棼篚痧矧酏镦骢钽糸镱ゥ荇镤稃韵南荏邈糸镱田玳痱镧蜥眄轭轶铒舂骢钽糸镱犰蔑铙殇弪翳骘祆秣轭箝眇戾祜玳痱镧蜥麸骈钿眭趱犰骘祆秣轭箫汩犰铄赭矧珧狃韬茆彗轭祗綮轶糸铉骘祆秣蟥觑桀磲蝙┊骘祆秣蟥磲蝙觑桀┊磲铢盹蝈骘祆秣蟥驷泗螽眭趱犰蟥噩侃涵骘祆秣蟥噩侃骘祆秣蟥佻丞苠钿祗綮轶糸铉茴镩钿孱渝磲铘殂犰禊痱邃殂狒弩扉脲荇屮趑酐骘祆秣簖犷荇屮趑酐眭趱犰簖狎骢钽糸镱轭麸怙镬遽铙骑祆秣轭翳轶轭趱轸轱瞵麇汜趄犷箪狒翳轶祜玳痱镧蜥轭麸骢钽糸镱犰镱搴茆彗轭泔溴茴犴妍骘祆秣簖墁茴犴妍眭趱犰簖茴犴妍躞弪荇茴犴妍躞弪荇荇怙镬苘茴犴妍骘祆秣簖芗芗浇茔镱篝觑桀荇犷浇茔镱篝磲蝙苘莛栳铘镯茴犴妍骘祆秣簖芗芗烬茴彗痂犷麸睇荇矧荇矧浇茔镱篝磲蝙荇犷浇茔镱篝觑桀苘莛栳铘镯茴犴妍骘祆秣簖芗芗烬茴彗痂犷麸睇荇矧荇矧莒滹趔苘茴犴妍眭趱犰簖芗芗茴犴妍骘祆秣簖芗芗茼狒栩屐茼狒桠纣犷潺茴犴妍骘祆秣簖芗芗苠钿泔溴茴镩钿孱疹骘螋躅狒屐翳轶驷殪麸汜痿躜翳溴箝蝈忮栳鲩矧镦翳祜玳痱镧蜥轭赭麽蠛茆彗轭溴筱蜷痿轱铨荛翦碹绣蜴矧磲钽搴碰弪汜祆麸茴犴妍眭趱犰簖滹弩赭扉铄狎箦狎汨弩怡汜祆轭茴犴妍骘祆秣簖麒弪尼翎祜黠蹯滹聃狍殪轭遽蝈灬糸镱犰觑轭苠眇棼镱沐犷蝈躞轸蝈篚祠狍祜镫躔翎忪瀹ボ骘雉铒翦族泔蹯箫祧翳轶怡礤盹辁轭茴犴妍骘祆秣簖犷茴犴妍眭趱犰簖深溴邃礤盹辁狒轱骘蝈箬徜秣秕狃痱镝汨轭翳狒轸ㄤ钺黹汜祆犷灬殪趱蝾忮栳鲩矧轭麸溽翎蕊麇鲥颥礤盹辁狒轱犰镱滹弩铒篚痧矧孱蹴弪狒轱瞵屮轶翦铘獒聃犷糸骈汜糸镱矧徵珧彗狒轱町荛翦碹渝磲铘殂蠛契钽糸镱轭骢钽糸镱犰犷轫疱蜥糸鲥灬铉踽珏狎溟蝈泗轱钺旌翳妁翎脲轭瘐趔麸秕麴豸螽澡躞ぼ钺礤眭趱犰簖芗芗汨邈塍麒弭桢箴邈殒殂躞弪狎眭趱犰蠡怩麇汜铑雉躞轸麸孱蹴弪狒眭趱犰骘祆秣蟋铒麸骈钿翳眭趱犰镦玳鲥躞弪ぎ苠钿溴筱蜷痿轱铨茴镩钿孱阻狒盹蝈秕钺堍轹骢钽糸镱犰狃痱镝汨汜铑雉栳钿戾苠眇棼屮轶翦铘獒聃犷糸骈汜糸镱矧轭溽翎忉箦疳蜢犷沐苠眇棼痱镪邈糸镱簖┊澡轶祜玳痱镧蜥骈钿溟蝈泗矧犷徙麸蝮麒栳鲥黠螂邃镱翳筢礤骈祉茆彗轭祗綮轶糸铉溟蝈泗邃哚泗矧拈蝈泗矧零麸颟涵溟蝈泗邃哝殪悫拈蝈泗矧崎祉┈篝狎蝈溥轭ㄆ殪憩零麸颟苠钿祗綮轶糸铉茴镩钿孱娱钽荇屮趑酐崎祉轶铒轭翳桢徜镦翳蝓戾轸轶铒孱蹴弪狒邃怡翳蝈灬糸镱荇屮趑酐溟蝈泗邃荇屮趱钿弪筱矧妍徙麸螨蜥翳弪翳桢徜轶溴蜷鲠忪殒翳弪苠眇棼屮轶趔犷荇屮趑酐崎祉翳狒磲脲翳怙澌趄蹂族汜屙忮翳轶骢钽糸镱犰禊茆彗轭泔溴ゥ茴犴妍溟蝈泗邃崎祉茴犴妍疱蝮镱荇茴犴妍骈祉荇荇怙镬茕雉筌ゥ茴犴妍篝狎蝈渖铨茴犴妍骈祉荇茴犴妍疱蝮镱荇荇怙镬茕雉筌茴犴妍溟蝈泗邃零麸螨茴犴妍疱蝮镱荇茴犴妍疱蝮镱荇荇怙镬苘茴犴妍溟蝈泗邃零麸螨芗茴犴妍溟蝈泗矧芗茴犴妍徙麸螨杰荞踽茴犴妍屮轶趔芗ㄜ骖茴犴妍骈祉茴犴妍溟蝈泗邃崎祉芗茴犴妍溟蝈泗矧芗茴犴妍骈祉苘荞踽莛栳铘镯茴犴妍屮轶趔芗ㄜ骖茴犴妍骈祉茴彗痂犷麸睇荇犷潲荇犷茴犴妍篝狎蝈渖铨芗茴犴妍骈祉芗茴犴妍徙麸螨苠钿泔溴茴镩钿孱澡轶蝈聃轵弩骢钽糸镱ぼ钺礤屮轶趔啕茴犴妍骈祉ㄜ钺礤骈祉荇荇怙镬荇荇怙镬が矧盹蝈珏铄蜥祆ぼ钺礤屮轶趔哕犰痂苕矧犰燔犰痂岙ㄜ犰痂荇荇怙镬荇荇怙镬ぎ迈翳弪轶铒镡鲩秕麽麸轫痨屙孱ぼ钺礤屮轶趔啕茴犴妍骈祉箬矧镦孱蹴弪狒轭犰骈祉蟋犷铒麽麸轫痨屙孱ぼ钺礤屮轶趔哕犰痂幛狒犰飚田玳痱镧蜥眄轭篚痧矧趔屮轶翦铘獒聃犷糸骈汜糸镱怡蝈赍泗轭轭瘐簸茯殓梏狎蝻鳏秕麴豸溟蝈泗轱钺扉豉眭汨狍骢钽糸镱轶磲翳屙狒殂犰禊箦镦轭瘐舡秕麴豸趱痨弩祜玳痱镧蜥眄轭痱邃殂狒汜孱蹴弪狒轸轭瘐舡秕麴豸趱痨弩矧蜥翳弪翳矬麒矬秕麴豸轶趄蹂ㄡ铢铒瞽孱蹴弪狒邃轭瘐趔狎轫痨殂轸禊驷祗濠族汜祆翳弩轭瘐趔翳苠眇棼篚痧矧酏镦痱邃殂狒瀹涉麇汜孱蹴弪狒翳篚痧矧镦ゆ茴犴妍骈祉荇荇怙镬が汜煦蹯狒轭ぼ钺礤屮轶趔芗妞轶箝眇戾轶翳篚痧矧铒瞽屙痿往棂痫翳弩轶轶翳狒麇汜磲脲翳钺堍轹骢钽糸镱犰趄犷箪狒轱镦祜玳痱镧蜥眢忮栳鲥泔蝌邈綮殒麇汜痿躜苠眇棼骢钽糸镱镦孱蹴弪徕戾篚痧矧舢燥箝眇扉纟翳痱镡戾憩麇骘沲桢蝈镱苠眇棼骈铋翦篚痧矧衄犷箅弭汨镱禊骝徵礤铘镦豉疱簌篝屙骘孱篚蜷铉骈铋翦篚痧矧衄痫篝痫铋铉礤翎翳屣蝙犷轫痨屙孱翎糸镱深趄殓蹰铉禊翳豉痖铉蝓戾骘孱篚蜷铉骈铋翦篚痧矧蝈箦礅戾翳秕玷轭屮徙綮豉疱簌篝屙躞轭珧徜邃ㄣ铹彐驽泗螽ゥ龄溟糸镱犰禊翳骢钽糸镱犰篝戾磲脲轸钺趱蜥麸徜赭痫麇蜴蹯驽狒躜弩ū栝玷弪矧溴泔眇豸狒轱瞵怡犰祜鏖铉怙翳骈铋翦禊篚痧矧翦骢钽糸镱蝈痱弩孱翦狍苠眇棼溽翎瀹绠翎忪濠犷狎忾趄狎痫篌殁禊栝玷弪矧溴骢钽糸镱蝈痱弩孱翦狍苠眇棼泔溴┗犷ú骈铋翦禊篚痧矧翦骢钽糸镱铄邃铒忮怙镬遽罨骈铋翦篚痧矧轶溴骈钺忪骘犷苠眇棼痫轭翦潺豉疱翳狒轶豉疱鏖翳溴箝珙狒邃噜弪铵鲠祯荇镤稃韵南骈铋箬ゥ茴镩钿孱ゥ荇镤稃韵南痫轭秕翳狒翳轶轶箝黹灬麸磲趄轼眭祠轲扉汜糸镱ゥ苒ゥ茔滹漏啕殡荏蹴哧吝殛茔滹逻觌ゥ茌ゥ茆彗轭祗綮轶糸铉ゥ蝈徙瑷篝狎舂ゥ蝈徙瑷侃涵蝈徙瑷丞邃珏ㄘ侃ゥ苠钿祗綮轶糸铉ゥ再猩吻艺膛茆彗轭骈珲蝈苒茆彗轭狎蜥蜚沆荇屮酐豉疱簖连茆铈羼茆铈矧茔麸茆铈矧荇轫弩ボ忸骘茆铈矧茕雉苘荇屮酐痫轭翦豉疱簖鞋茆铈羼荀轸茆铈矧茱糸礤茆铈矧莒麸茆铈矧苕麸ゥ茆铈矧荇磲忮茆铈矧荇怙镬苘荇屮酐翦蝽簖茆铈羼茆铈矧茆铈矧苕铥茆铈矧暹避煎卟茆铈矧ㄥ弑墁暹博茆铈矧莛檫芗ボ忸骘荇徕篚蜾茆铈矧茕雉苘荇屮酐痫轭翦翦蝽簖衄茆铈羼茆铈矧苕铥茆铈矧芗茆铈矧芗茆铈矧衄酴茆铈矧莛檫芗茆铈矧莒弭疳轵酏觚茆铈矧莒弭羼茆铈矧荇铋ボ忸骘荇犷茆铈矧荇矧ボ忸骘荇牾篝茆铈矧莒弭牾篝苘荇屮酐泔铘屮趔芮芟茆铈羼苠眇豉泺茆铈矧芮荑苘荇屮酐痫轭翦泔铘屮趔苣ガ芴芴犴怃苄箝茆铈羼苠眇豉泺茆铈矧苣荑苘ゥ荇屮酐骈铋翦篚痧矧泔铘屮趔芟茆铈羼苠眇豉泺茆铈矧芟荑ゥ苘苠钿狎蜥茌茆彗轭磲翳疳螨荛铈弪垓殓梏介钽祯溴蓰苁芮苠眇豉泺苠眇豉泺茔芮荛铈弪垓殓梏仅狎蓰{\J x P \G {\hyp x P} {\emptycx}}

    \infer*[right=nil]{}{\J \tnil P \G \D \O}

    %% FINITE MAPS
    \infer*[right=$\fto$\,i]{
      \J t P \G \D {\O, \hyp x A}
    }{
      \J {\fn x t} {A \fto P} \G \D \O
    }

    \infer*[right=$\fto$\,e]{
      \J t {A \fto P} \G {\D} {\O}
      %% \\\\
      %% \pJ p A {\G,\O_1} {\D_2} {\O_2}
    }{
      \J {t\<x} P \G {\D} {\O, x : A}
    }

    \infer*[right=$\with$\,i]{
      \J t P \G \D \O
      \\\\
      \J u Q \G \D \O
    }{
      \J {(t,u)} {P \with Q} \G \D \O
    }

    \infer*[right=$\with$\,e]{
      \J t {P_1 \with P_2} \G \D \O
    }{
      \J {\pi_i\<t} {P_i} \G \D \O
    }

    \infer*[right=$\ox$\,i]{
      \J t P \G {\D_1} {\O_1}
      \\\\
      \J s Q {\G, \O_1} {\D_2} {\O_2}
    }{
      \J{(t,s)}{P \ox Q}{\G}{\D_1 \cup \D_2}{\O_1, \O_2}
    }

    \infer*[right=$\ox$\,e]{
      \J t {P \ox Q} \G {\D_1} {\O_1}
      \\\\
      \J s Q {\G, \O_1} {\D_2, \hyp{x}{P}, \hyp{y}{Q}} {\O_2}
    }{
      \J{\letpair{x}{y} t s}{Q}{\G}{\D_1 \cup \D_2}{\O_1, \O_2}
    }

    %% LINEAR MAPS
    \infer*[right=$\lto$\,i]{
      \J t Q \G {\D, \hyp x P} {\emptycx}
    }{
      \J {\fn x t} {P \lto Q} \G \D {\emptycx}
    }

    \infer*[right=$\lto$\,e]{
      \J t {P \lto Q} \G {\D_1} {\O_1}
      \\\\
      \J u {P} {\G,\O_1} {\D_2} {\O_2}
    }{
      \J{t\<u}{Q}{\G}{\D_1 \cup \D_2}{\O_1, \O_2}
    }

    \infer*[right=let]{
      \J t P \G {\D_1} {\O_1}
      \\\\
      \J u Q {\G, \O_1} {\D_2, x : P} {\O_2}
    }{
      \J {\leteq x t u} Q \G {\D_1 \cup \D_2} {\O_1,\O_2}
    }
  \end{mathpar}

  \caption{Sketch of syntax and type system}
  \label{fig-system}
\end{figure*}


\section{Type system}

\newcommand\defeq\triangleq
%\renewcommand\defeq{\overset{\text{def}}{=}}

\Cref{fig-system} gives a sketch of the syntax and typing rules for a simply-typed $\lambda$-calculus capturing finite support, and \cref{fig-primitives} gives types for primitive functions on booleans.
We consider two kinds of types, normal $A,B$ and pointed $P,Q$.
A pointed type $P$ is a type with a designated point, $\tnil_P \in P$.
A function $f : A \fto P$ is finitely supported iff $\name{support}\<f \defeq \{x \in A : f\<x \ne \tnil_P\}$ is finite.
This generalizes (finite) support to non-boolean functions.

\begin{figure}
  \[\begin{array}{r@{\hskip 0.3em}l}
  %\begin{align*}
    \name{true} &: \tbool\\
    \name{and} &: \tbool \ox \tbool \lto \tbool\\
    \name{or} &: \tbool \with \tbool \lto \tbool\\
    \name{exists} &: (A \fto \tbool) \lto \tbool\\
    \name{eq} &: A \cto (A \fto \tbool)
  %\end{align*}\vspace{-1.5\baselineskip}
  \end{array}\]\vspace{-1\baselineskip}
  \caption{Primitive functions}
  \label{fig-primitives}
\end{figure}

We write $f : A \fto P$ for finitely supported maps, besides which we have two more kinds of map: unrestricted $g : A \cto B$ and point-preserving $h : P \lto Q$, meaning that $h(\tnil_P) = \tnil_Q$.
%
Point-preserving maps are useful because they preserve finite support: if $h$ preserves points then $\fn x h \<(f \<x)$ has finite support if $f$ does.

We have two typing judgments, which we can gloss using our function types:

\begin{center}
  \begin{tabular}{l@{\hskip 2em}l}
    \em Judgment & \em Rough interpretation
    \\
    $\cJ e A \G$ & $\G \cto A$
    \\
    $\J t P \G \D \O$ & $\G \cto (\D \lto (\O \fto P))$
  \end{tabular}
\end{center}

\noindent
The first, $\cJ e A \G$, types `unrestricted' terms that do not interact with finite support or pointed types; it is defined by the usual rules of simply typed $\lambda$ calculus (with $A \cto B$ as function type), which we omit for brevity, plus \textsc{include}.

In the second, $\J t P \G \D \O$, the three typing contexts correspond to our three kinds of function, resembling linear-nonlinear logic.
%
The unrestricted context $\G$ obeys the usual structural rules.
%
The point-preserving context $\D$ obeys the substructural rules of \emph{relevance logic:} variables must be used \emph{at least} once.
Dropping variables is unsound; for example, constant functions like $\fn x 5$ do not preserve \tnil.
%
Finally, the finitely supported context $\O$ does not even have a variable rule! After all, $\fn x x$ is not finitely supported.
%
Instead, eliminating a finitely supported variable requires applying a finitely supported map (\textsc{$\fto\,$e}).
This resembles a monad graded by the context $\O$; applying a finitely supported map is graded monadic join.

The unrestricted and finitely supported contexts interact via \emph{grounding.} For instance, in $\leteq x t u$, variables finitely supported by $t$ may be used \emph{unrestricted} in $u$ so long as $u$ uses $x$ in a point-preserving way.
This internalizes the fact that point-preserving maps preserve finite support.

Our pointed types have the two products characteristic of linear logic: the additive direct product $P \with Q$ of pairs with $\tnil_{P \with Q} = (\tnil_P, \tnil_Q)$; and the multiplicative tensor product $P \otimes Q$, which is the ``smash'' quotient of the direct product by $\tnil_{P \otimes Q} = (\tnil_P, y) = (x, \tnil_Q)$ for any $x : P$ or $y : Q$.
The easiest example of this distinction is that \name{and} takes $\tbool \ox \tbool$, because $\name{and} \<(x,y)$ preserves points in both arguments: it is false ($= \tnil_\tbool$) if either $x$ or $y$ is. But $\name{or} \<(x,y) = \tnil$ only if both $x,y$ are $\tnil$, so $\name{or}$ accepts $\tbool \with \tbool$.


%% \noindent
%% \todo{NUMEROUS PROBLEMS:}

%% 1. shouldn't $\leteq x t u$ be derivable as syntax sugar? what even is its cut reduction / $\beta$-reduction / substitution-based operational semantics?

%% 2. how do we make \name{or} definable? what about \name{exists}?
%% \name{or} is definable via outer-join property, $\name{outer} : \tmaybe \<A \with \tmaybe B \lto \tmaybe (A + B + A \times B)$? yech! and this doesn't handle exists. could have a ``comm. monoid'' typeclass, $P$ a c.mon if it admits $\name{plus} : P \with P \lto P$ and $\name{sum} : (A \fto P) \lto P$, but this doesn't allow defining \name{outer}, does it?


%% \section{Challenges}

%% \subsection{implementation strategies}

%% when do you materialize?
%% (at duplication, I guess?? hm, another layer of linear nonlinear???!?)

%% \subsection{alternating contexts?}

%% \subsection{recursively defined `finite' maps}

%% Recursion: what should it do? how do we give it semantics, operational or denotational? how do we implement it?

%% productive streaming nontermination a la lambda join?
%% iterate to fixed point and only then yield a la Datalog?
%% some hybrid?

%% \subsection{interaction with normal recursive functions}

%% should we even allow them? should we have a 2-level language where the functional bit is metaprogramming for the first-order finite bit?


%% \section{Lipsum}
%% \lipsum


%% \section{Contributions}

%% Our main contributions are: \todo{TODO}


%% %% Bibliography
%% \bibliographystyle{abbrvnat}
%% \bibliography{datafun}

\end{document}
