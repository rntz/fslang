\documentclass{article}

\usepackage[letterpaper,
  hratio=1:1,vratio=3:4,
  %text={152mm,228mm}, % 2:3
  text={162mm,228mm}, % 5:7
]{geometry}

%% FONTS & TYPOGRAPHY

%% %% ---------- OPTION 1: CHARTER ----------
%% \usepackage[sups,scaled=.96]{XCharter}
%% \usepackage[scaled=1.010417965903645]{inconsolata}
%% \usepackage[scaled=0.95,proportional,semibold]{sourcesanspro}
%% %\usepackage[osf,scaled=1.007,scaled=1.033,scaled=1.02,]{AlegreyaSans}
%% \usepackage{eulervm}
%% \edef\zeu@Scale{0.99}
%% \PassOptionsToPackage{scaled=\zeu@Scale,bbscaled=\zeu@Scale,scrscaled=\zeu@Scale}{mathalfa}
%% \RequirePackage[cal=cm]{mathalfa}
%% %% Make sure \mathbold and \mathvar are defined.
%% \linespread{1.06667}            %eyeballed
%% \usepackage{amsmath,amsthm}
%% \usepackage{amssymb}            %\multimap

%% ---------- OPTION 2: PALATINO ----------
\usepackage[scaled=.96,largesc,nohelv]{newpxtext}
\usepackage[scaled=1.0176]{biolinum}
\usepackage[scaled=0.964203422764601]{inconsolata}
\edef\zeu@Scale{.96}
%% HACK: newpxtext doesn't respect fontaxes' \tbfigures! :( but it _does_
%% define, eg., \tlfstyle! hm...
\usepackage{fontaxes}
\renewcommand\tbfigures{}
\renewcommand\lnfigures{}
%\linespread{1.023435141098595}
\linespread{1.08}              % eyeballed 2025-02-06
%% %% NEWPXMATH %%
%% \usepackage[scaled=.96,vvarbb,smallerops]{newpxmath}
%% \usepackage[bb=ams,bbscaled=.96,cal=cm]{mathalfa}
%% EULER MATH %%
\usepackage{eulervm}
\PassOptionsToPackage{scaled=\zeu@Scale,bbscaled=\zeu@Scale,scrscaled=\zeu@Scale}{mathalfa}
\usepackage[cal=cm]{mathalfa}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}            %\multimap

%% %% END FONTS & TYPOGRAPHY

\usepackage[dvipsnames]{xcolor}
%% cleveref must be loaded AFTER hyperref & amsmath, or it errors; and AFTER
%% amsthm and BEFORE we define theorem styles, otherwise (eg) it calls lemmas
%% "Theorem"s.
\usepackage{hyperref,url}
%\usepackage{amsmath,amsthm}
\usepackage[nameinlink,noabbrev]{cleveref}
\usepackage{mathpartir}
\usepackage{mathtools}          %\Coloneqq, \dblcolon
%\usepackage{amssymb}            %\multimap
\usepackage{stmaryrd}           %\llbracket, \shortrightarrow
\usepackage{array}              %\setlength\extrarowheight
\usepackage{booktabs}           %\midrule
\usepackage{accents}            % for \underaccent

\newcommand\crefrangeconjunction{--} % use en-dashes for ranges.
\creflabelformat{equation}{#2#1#3}
\crefformat{footnote}{#2\footnotemark[#1]#3} % referencing footnotes

\newcommand\ensuretext[1]{{\ifmmode\text{#1}\else{#1}\fi}}
\newcommand\strong[1]{{\bfseries#1}}
\newcommand\interpunct{\ensuretext{\textperiodcentered}}

\newcommand\G\Gamma
\newcommand\D\Delta
\renewcommand\O\Omega
\renewcommand\L\Lambda

\newcommand\lto\multimap        % "linear \to"
%\newcommand\fto{\underset{\textsf{fin}}{\to}}           % finite map
\newcommand\fto{\Rightarrow}
\newcommand\x\times
\newcommand\ox\otimes
\newcommand\tbool{\ensuremath{2}}
\newcommand\tmaybe[1]{\ensuremath{{#1}_{*}}}
\renewcommand\tmaybe[1]{\ensuremath{\text{Maybe}１茴鬻泔眄犷滠躅溴螋疱鄄蓰荃钿弪徙沐铘荇屮趔纣荃痼栳疱荏泱栳疱１２茴鬻泔眄犷滠羼糅陛荃钿弪豉疱羼１茴鬻泔眄犷滠忸驽覃苊镬镱羼颀茴鬻泔眄犷滠忸骘螓茼狒栩屐墁墁ボ铄縻镯磲钿苠眇豉泺荟狎屦箝祜茴鬻泔眄犷滠屙痿泺茔滹酏ボ蝈铄縻镯磲钿苠眇豉泺墁ボ蝈铄縻镯磲钿苠眇豉泺荇屮酐ボ蝈铄縻镯磲钿苠眇豉泺荇屮趱钿弪筱矧妪茴鬻泔眄犷滠棂疔草１茱２茴鬻泔眄犷滠梵ヨ痫翳弩轶箦疳蜥麸茴鬻泔眄犷滠镦茼狒桠轭糊ボ蝈铄縻镯磲钿茱纣
\newcommand\cxsep{\mathbin{/}}

\newcommand\cJ[3]{{#3} \,\vdash\, {#1} : {#2}}
\newcommand\J[5]{{#3} \cxsep {#4} \cxsep {#5} \,\vdash\, {#1} : {#2}}
%\newcommand\pJ[5]{{#3} \cxsep {#4} \,\vdash\, {#1} : {#2} \dashv {#5}}
%\newcommand\pJ[5]{{#3} \cxsep {#4} \cxsep {#5} \,\vdash\, {#1} : {#2}}
\newcommand\pJ[5]{{#3} \cxsep {#4} \cxsep {#1} : {#2} \,\vdash\, {#5}}
%\renewcommand\pJ[5]{{#3} \cxsep {#4} \,\vdash\, {#1} : {#2} \rightsquigarrow {#5}}
%% \renewcommand\pJ[5]{{#3} \cxsep {#4} \cxsep {#2} \,\vdash\, {#1} : {#5}}

\newcommand\ppJ[6]{{#3} \cxsep {#4} \cxsep {#1} : {#2} \,\vdash\, {#5} \cxsep {#6}}
%\renewcommand\ppJ[6]{{#3} \cxsep {#4} \,\vdash\, {#1} : {#2} \rightsquigarrow {#5} \cxsep {#6}}

%% %% Hide terms and hypotheses.
%% \renewcommand\J[5]{{#3} \cxsep {#4} \cxsep {#5} \,\vdash\, {#2}}
%% \renewcommand\hyp[2]{#2}

\newcommand\fname\textit        %function name
\newcommand\cname\text          %constructor name

\newcommand\fnspace\:           %binder space
\newcommand\fn[1]{\lambda{#1}.\fnspace}
\newcommand\<\;                 %function application space

\newcommand\cnil{\cname{nil}}
\newcommand\cjust{\cname{just}}
\newcommand\ctrue{\cname{true}}
\newcommand\cfalse{\cname{false}}

\newcommand\tnil{\cnil}
\newcommand\tjust[1]{\cjust\<{#1}}
\newcommand\letin[2]{\text{let}１荇屮酐轭２茴鬻泔眄犷滠戾翦褊齿莒弭轭１２３茴鬻泔眄犷滠戾絷躞糅齿莒弭羼荇牾篝１２３茴鬻泔眄犷滠戾麴衢蜊摧莒弭羼１２３４茴鬻泔眄犷滠翎钿茼狒栩屐荇屮趔纣犷潺茴鬻泔眄犷滠麸螓茼狒栩屐荇屮趔纣矧茴鬻泔眄犷滠趑蝓妍茔趄蹂茴鬻泔眄犷滠翩犰箦茔驷祗妪茴鬻泔眄犷滠翎怏躜潲苕钺礤徕篚蜾芗茴鬻泔眄犷滠疱覃↓茴鬻泔眄犷滠轶猁茼狒栩屐墁很茴鬻泔眄犷滠溴钲陛莒焘蜥汶弭１茯蜮蜥汶弭茴鬻泔眄犷滠麸滹泔祜螓茔镬矧蝈潺茴鬻泔眄犷滠麸滹郾蓰苠铙躜弭屮酐荇镤镢镬矧１茴鬻泔眄犷滠荇镤稃刎佚荏弭戾铉翳莛狎轭溴铘梆酏荏弭戾铉翳莛狎箅轲插茆彗轭滹沲礤铘茴镩钿孱糗翦趔沱聃殂珲殇麸铒翎糸镱茴鬻泔眄犷滠篚痧矧酐苠铙躜屙狒棼苕钺礤篚痧矧酏茴鬻泔眄犷滠篚痧矧麸孥陛苠铙躜屙狒棼荏躔痫螋１茴鬻泔眄犷滠溴驽覃荇蜷犷珈羼茆彗轭翎怩灬螨祆瘥卑沩蝠驳眄瘥北绊睚荛御铘狲荛吾礤荛深翦蝠蝈翎糸镱苘ち陇赠疱渝趔苘ち荇陇契钽糸镱契钽糸镱筌ば绚酗轭翦豉疱渝趔鏖翳溴箝珙狒邃囵镩铘矧帔弪铵黩轸翦ぼ纛殪が矧ぼ纛殪咝麸磲脲翳豉疱屮痨殂轸骑轭篝犷沐怙镬遽铙鏖翳ぼ纛殪荇屮酐驷祗妪が矧翳轭翦珏蝮鏖翳ぼ纛殪挨苘ば莒麸绚酗轭舡痱弩弪鲩铉磲痼契钽糸镱翳狒痱弩弪鲥ぼ纛殪が翳狒轶ゆㄜ纛殪咝荇铋爝绚苘ち苕麸肖崎铋翦磲痼契钽糸镱ゆ荇肖篚汨翳狒ぼ篚痧矧麸纣纨茕彐羼茺妯茴荇铋荦轶骈铋翦族蝈痱弩孱翳弩轭礤盹蝙狍苠眇棼轭瘐舡秕麴豸翎忪弩扉篝轭镱禊疳轵ゆ麒弪茴荇铋欷骈铋翦篚痧矧礤犷翳弪狎骈铋翦禊磲铢篚汨疳轵螽苠钿翎怩灬螨茴镩钿孱荇屮趔沱珧犴磲蝮苒茆彗轭狎蜥蜚沆荇屮酐豉疱簖连茆铈羼茆铈矧茆铈矧荇轫弩茆铈矧荇茆铈矧苘荇屮酐痫轭翦豉疱簖鞋茆铈羼荇磲忮茆铈矧荇轫弩茆铈矧茱糸礤ボ忸骘茱痨躞茆铈矧莒麸茆铈矧苕麸苘荇屮酐翦蝽簖茆铈羼茆铈矧苕铥茆铈矧暹避煎卟茆铈矧ㄥ弑墁暹博茆铈矧莛檫芗茆铈矧荇徕篚蜾茆铈矧苘荇屮酐痫轭翦翦蝽簖衄茆铈羼茆铈矧苕铥茆铈矧芗茆铈矧芗茆铈矧衄酴茆铈矧莛檫芗茆铈矧莒弭疳轵酏觚苘Ζ荇铋茆铈矧荇牾篝茆铈矧莒弭牾篝苘Ζ莒弭羼苘荇屮酐疳趑弪铙岈茆铈羼茆铈矧茆铈矧莛羼荇镤镢镬矧妪ン栾蹯翳轶忮翦蝽矧痫轭翦翦蝽茆铈矧ㄡ猢苘荇屮酐痫轭翦疳趑弪铙瓞茆铈羼茆铈矧荇牾篝茆铈矧瓞瘵苘荇屮酐泔铘屮趔芮芟茆铈羼苠眇豉泺茆铈矧芮荑苘荇屮酐痫轭翦泔铘屮趔苣芴芴犴怃苄箝茆铈羼苠眇豉泺茆铈矧苣荑苘ゥ荇屮酐骈铋翦篚痧矧泔铘屮趔芟茆铈羼苠眇豉泺茆铈矧芟荑ゥ苘苠钿狎蜥茌茴镩钿孱糗翦趔沱牾溏礤铘犷翳彘蝻蹒轭翦蝠蝈翎糸镱茆彗轭翎怩灬螨炖荑箅轲插睚炖荑箅轲插睚炖荑箅轲插睚忑苠蔑铘屮苠砒犴痨苠深翦蝠蝈翎糸镱苠彭痿泔铘屮轭翦蝠蝈翎糸镱苘ぼ乾芟ぼ棂瘥弑吝饼墁茕雉蟋墁荑瘥哳吝铨ち弑荇轫弩茕雉荇轫弩吝瞍け荇磲忮褒苘ぼ默芴ぼ棂瘥弑羞饼墁茕雉蟋墁荑瘥哳羞铨ば弑茱茕雉茱羞瞍げ荇磲忮饼荇磲忮ㄜ繇狴忮褒苠钿翎怩灬螨茆彗轭翎怩灬螨炖荑箅轲插睚炖荑箅轲插睚忑苠术溏礤铘苠深翦蝠蝈翎糸镱苘ぼ闶芮ぼ荇沥苘ぼ芮苣芟ぼ荇苣莒麸芟苕麸肖苘ぼ鹗芮苣芟ぼ荇苣莒麸荇荇磲忮芟苘ぼ痧芮苣芟芴ぼ荇苣莒麸莒麸ㄜ繇狴忮芟茱芴ゥ荇屮糸酐铒翦翳篦狃痖铉镦ち芟ぁ苠钿翎怩灬螨ゥ苒ゥ茆彗轭狎蜥炖荑箅轲插睚炖荑箅轲插睚炖荑箅轲插睚忑ゥ荇屮糸酐蔑铘屮酏荇屮糸酐砒犴痨妪荇屮糸酐深翦蝠蝈翎糸镱ゥ荇屮糸酐彭痿泔铘屮酏ゥ苘ゥ芮芟荑瘥弑吝饼墁茕雉蟋墁荑瘥哳吝铨吝荇轫弩茕雉荇轫弩吝ゥ荇磲忮褒ゥ苘ゥ苣荑瘥弑羞饼墁茕雉蟋墁荑瘥哳羞铨羞茱茕雉茱羞ゥ荇磲忮饼荇磲忮ㄜ繇狴忮褒苘ゥ苘ゥ苘ゥ荇屮糸酐术溏礤铘荇屮糸酐深翦蝠蝈翎糸镱ゥ苘ゥ茔芮ゥ芮荇ゥ苘ゥ苁芮苣芟ゥ芮荇苣莒麸芟苕麸ゥ苘ゥ莛芮苣芟ゥ芮荇苣莒麸荇荇磲忮芟ゥ茼蹯糸泔祯眍昌忑荇镤稃麒铒ぼ荇荇苣莒麸荇磲忮芟たゥ苘ゥ莛芮苣芟ゥ芮荇苣莒麸莒麸芟ゥゥ荇屮糸酐铒翦翳篦狃痖铉镦ち芟ぁゥ苠钿狎蜥ゥ茌茴镩钿孱荇镤稃歪忮翳轶箬秕熹忮蝈滹铄麸犰祜狎忾趄狎铄篝轭绡轭翦蜢遽鲩铉镦犰翳蝈腴钿镦泔铘屮舢渝噜幸下膛陀Ё忮祜鳟硫孱骈铋翦禊篚痧矧翦磲痼珧徜邃盹钺秭弪痫轭翦箦趔向铒艨茴镩钿孱糗翦趔沱轭驽蝈钽蝓戾簖苠眇棼藻蝽豉痖铉ぼ闶芮茆彗轭磲翳疳螨荛铈弪垓殓梏仅狎蓰荑荛芮茔芮荛铈弪垓殓梏介钽祯溴蓰苁芮苠眇豉泺苠眇豉泺茔芮荛铈弪垓殓梏结怏躜漭茔芮茔荇徕篚蜾妪芮苘荇屮酐犷翳雉桢镡鲩秕蝓戾螽苠钿磲翳疳螨苠眇棼酗轭翦翦蝽豉痖铉ぼ芮苣芟茆彗轭磲翳疳螨ゥ瘴芍乓恿艺膛荛铈弪垓殓梏仅狎蓰{\J x P \G {\hyp x P} {\emptycx}}

  \infer*[right=include]{\cJ e P \G}{\J e P \G \emptycx \emptycx}

  \infer*[right=nil]{}{\J {\tnil} P \G \D \O}

  \infer*[right=let]{
    \J t P \G {\D_1} {\O_1}
    \\
    \J u Q {\G,\O_1} {\D_2} {\O_2}
  }{
    \J {\leteq x t u} Q \G {\D_1\cup\D_2} {\O_1,\O_2}
  }
  \\
  %% PRODUCTS
  \infer*[right=$\x$\,i]{
    \J t P \G \D \O
    \\
    \J u Q \G \D \O
  }{
    \J {(t,u)} {P \x Q} \G \D \O
  }

  \infer*[right=$\x$\,e]{
    \J t {P_1 \x P_2} \G \D \O
  }{
    \J {\pi_i\<t} {P_i} \G \D \O
  }
  \\
  %% TENSOR PRODUCTS
  \infer*[right=$\ox$\,i]{
    \J t P \G {\D_1} {\O_1}
    \\
    \J s Q {\G\hs \O_1} {\D_2} {\O_2}
  }{
    \J{(t,s)}{P \ox Q}{\G}{\D_1 \cup \D_2}{\O_1\hs \O_2}
  }

  \infer*[right=$\ox$\,e]{
    \J t {P \ox Q} \G {\D_1} {\O_1}
    \\\\
    \J s Q {\G\hs \O_1} {\D_2\hs \hyp{x}{P}\hs \hyp{y}{Q}} {\O_2}
  }{
    \J{\letpair{x}{y} t s}{Q}{\G}{\D_1 \cup \D_2}{\O_1\hs \O_2}
  }
  \\
  %% LINEAR MAPS
  \infer*[right=$\lto$\,i]{
    \J t Q \G {\D, \hyp x P} {\emptycx}
  }{
    \J {\fn x t} {P \lto Q} \G \D {\emptycx}
  }

  \infer*[right=$\lto$\,e]{
    \J t {P \lto Q} \G {\D_1} {\O_1}
    \\
    \J u {P} {\G,\O_1} {\D_2} {\O_2}
  }{
    \J{t\<u}{Q}{\G}{\D_1 \cup \D_2}{\O_1, \O_2}
  }
  \\
  %% MAYBE
  \infer*[right=maybe\,i]{
    \cJ e A \G
  }{
    \J {\tjust e} {\tmaybe A} \G \emptycx \emptycx
  }

  \infer*[right=maybe\,e]{
    \J t {\tmaybe A} \G {\D_1} {\O_1}
    \\
    \J u P {\G, \O_1, \hyp x A} {\D_2} {\O_2}
  }{
    \J {\letjust x t u} {P} \G {\D_1 \cup \D_2} {\O_1,\O_2}
  }
  \\
  %% FINITE MAPS
  \infer*[right=$\fto$\,i]{
    \J t P \G \D {\O, \hyp x A}
  }{
    \J {\fn x t} {A \fto P} \G \D \O
  }

  \infer*[right=$\fto$\,e]{
    \J t {A \fto P} \G {\D_1} {\O_1}
    \\
    \pJ p A {\G,\O_1} {\D_2} {\O_2}
  }{
    \J {t\<p} P \G {\D_1\cup\D_2} {\O_1,\O_2}
  }
\end{mathpar}


\emph{Pattern typing, }$\pJ a A \G \D \O$
\begin{mathpar}
  %% \infer*[right=include \todo{\em - not sound!! let $P = Q_1 \lto Q_2$ and $p = x$}]{
  %%   \ppJ p P \G \D \O \L
  %% }{
  %%   \pJ p P \G \D {\O,\L}
  %% }
  \infer*[right=limited include]{
    \ppJ p P \G \D \O \emptycx
  }{
    \pJ p P \G \D {\O}
  }

  \infer*[right=var]{}{
    \pJ x A \G \emptycx {\hyp x A}
  }

  \infer*[right=$\x$]{
    \pJ a A \G {\D_1} {\O_1}
    \\
    \pJ b B {\G,\O_1} {\D_2} {\O_2}
  }{
    \pJ {(a,b)} {A \x B} \G \D {\O_1,\O_2}
  }

  \infer*[right=eq]{
    \cJ e {\eqt A} \G
  }{
    \pJ {\peq e} {\eqt A} \G \emptycx \emptycx
  }
\end{mathpar}

The main motivation for \textsc{limited include} is matching on `$\cjust$' in a finite map application:
\begin{mathpar}
  \infer*[right=$\fto$\,e]{
    \infer*[right=var]{}{
      \J f {\tmaybe{A} \fto P} \G {\hyp f {\tmaybe{A} \fto P}} \emptycx
    }
    \\
    \infer*{
      \infer*[right=just]{
        \infer*[right=var]{}{
          \pJ x A \G \emptycx {\hyp x A}
        }
      }{
        \ppJ {\tjust x} {\tmaybe A} \G \emptycx {\hyp x A} \emptycx
      }
    }{
      \pJ {\tjust x} {\tmaybe A} \G \emptycx {\hyp x A}
    }
  }{
    \J {f\<(\tjust x)} P \G {\hyp f {\tmaybe{A} \fto P}} {\hyp x A}
  }
\end{mathpar}

However, \textsc{limited include} has several issues:
\begin{enumerate}
\item We need $\D = \emptycx$ in \textsc{limited include} because $\D$ gets tensored together while $\O$ gets cross-producted, and we can't convert $\D_\ox$ into $\D_\x$ in general.

\item We must decide whether a cartesian pattern matches or fails, but we \emph{don't} need this for pointed patterns; this amounts to deciding ``equality with the point'' on the output of pointed pattern matching. This makes me nervous about the semantics of \textsc{limited include}. \todo{Do I have any problematic examples?}

\item Finally, including pointed patterns in patterns causes syntactic ambiguity: does the pattern $x$ signify a cartesian variable or the inclusion of a pointed variable?
\end{enumerate}

\emph{Pointed pattern typing, }$\ppJ p P \G \D \O \L$
\begin{mathpar}
  \infer*[right=var]{}{
    \ppJ x P \G \D {\emptycx} {\hyp x P}
  }

  \infer*[right=just]{
    \pJ a A \G \D \O
  }{
    \ppJ {\tjust a} {\tmaybe A} \G \D \O {\emptycx}
  }

  \infer*[right=$\ox$]{
    \ppJ p P \G {\D_1} {\O_1} {\L_1}\\
    \ppJ q Q \G {\D_2} {\O_2} {\L_2}
  }{
    \ppJ {(p,q)} {P \ox Q} \G {\D_1 \cup \D_2} {\O_1,\O_2} {\L_1, \L_2}
  }
\end{mathpar}


\noindent\textsc{rough denotational justifications for selected rules}

%% denotational function
\newcommand\dmap[3]{{#1} \to {#2} \lto {#3} \fto}
\newcommand\darg[3]{{#1}\ {#2}\ {#3}}
\newcommand\dfn[3]{\darg{#1}{#2}{#3} \mapsto}
\newcommand\g\gamma
\renewcommand\d\delta
\renewcommand\o\omega

\begin{align*}
  %% Linear variables
  &
  \infer*[right=var]{}{
    \J x P \G {\hyp x P} {\emptycx}
  }
  &&
  %% \infer{}{\dmap \G P 1 P}
  P \cong 1 \fto P
  %% &
  %% \darg{\g} p {()} &\mapsto p
  \\[1em]&
  %% A -o B intro
  \infer*[right=$\lto$\,i]{
    \J t Q \G {\D, \hyp x P} {\emptycx}
  }{
    \J{\fn x t}{P \lto Q}{\G}{\D}{\emptycx}
  }
  &&
  %% TODO: Do we need $\Omega=\emptycx$?
  %% Why? Explain this somewhere
  \infer{
    P \lto (1 \fto Q)
  }{
    1 \fto {(P \lto Q)}
  }
  \text{but not}  \infer{
    P \lto (A \fto Q)
  }{
    A \fto {(P \lto Q)}
  }
  %% &
  %% \darg{\g}{\d}{()} &\mapsto \fn{p} \den t\<\g\<(\d, p)\<()
  \\[1em]&
  %% A -o B elim
  \infer*[right=$\lto$\,e]{
    \J t {P \lto Q} \G {\D_1} {\O_1}
    \\\\
    \J u {P} {\G,\O_1} {\D_2} {\O_2}
  }{
    \J{t\<u}{Q}{\G}{\D_1 \cup \D_2}{\O_1, \O_2}
  }
  &&
  %% TODO: note the implicit use of duplication here!
  \infer{
    \D_1 \lto \O_1 \fto (P \lto Q)
    \\\\
    \O_1 \to \D_2 \lto \O_2 \fto P
  }{
    \D_1 \ox \D_2 \lto \O_1 \x \O_2 \fto Q
  }
  \quad
  \todo{check this}
  %% &
  %% \darg{\g}{(\d_1,\d_2)}{(\o_1,\o_2)} &\mapsto
  %% \den t \<\g \<\d_1 \<\o_1 \<(\den s \<(\g,\o_1) \<\d_2 \<\o_2)
\end{align*}


\[
\setlength{\arraycolsep}{1em}
\def\arraystretch{4}
\begin{array}{ccl}
  \infer[var]{}{
    \J x P \G {\hyp x P} {\emptycx}
  }

  &
  \infer{}{\dmap \G P 1 P}

  &
  \dfn{\g}{p}{()} p
  \\
  \infer[$\lto$ intro]{
    \J t Q \G {\D, \hyp x P} {\emptycx}
  }{
    \J{\fn x t}{P \lto Q}{\G}{\D}{\emptycx}
  }

  &  
  \infer{
    \dmap \G {\D \ox P} 1 Q
  }{
    \dmap \G \D 1 {P \lto Q}
  }

  &
  \dfn{\g}{\d}{()} \fn{p} t\<\g\<(\d \ox p)\<()

  %% &\raggedright\sffamily\small
  %% Does this need $\Omega=\emptycx$?
  \\
  \infer[$\lto$ elim]{
    \J t {P \lto Q} \G {\D_1} {\O_1}
    \\\\
    \J t {P} {\G,\O_1} {\D_2} {\O_2}
  }{
    \J{t\<s}{Q}{\G}{\D_1 \cup \D_2}{\O_1, \O_2}
  }

  &
  \infer{
    \G \to \D_1 \to \O_1 \fto P \lto Q
    \\\\
    \G \x \O_1 \to \D_2 \lto \O_2 \fto P
  }{
    \G \to \D_1 \ox \D_2 \lto \O_1 \x \O_2 \fto Q
  }

  &
  \xxx
\end{array}
\]


\noindent\textsc{the structural problem: finite maps don't commute with functions}

Although we haven't included it in our grammar, $A \to P$ is a pointed type, with $\tnil_{A \to P} = \fn x \tnil_P$.
%
Moreover, function spaces commute with point-preserving function spaces: $A \to (P \lto Q) \cong P \lto (A \to Q)$.
%
So we need not worry about the `relative order' of hypotheses in $\G$ and $\D$.
%
We can combine them into one context, or keep them separate, as we please.

Unfortunately, functions and finitely supported maps do \emph{not} commute: $A \to (B \fto P) \ncong B \fto (A \to P)$. As a counterexample, consider equality:

\begin{align*}
\fname{eq} &: A \to A \fto \tbool
&
\fname{eq}' &\!\!\not\,\,: A \fto A \to \tbool
\qquad\color{red}\textit{(ill-typed!)}
\\
\fname{eq}\<x \<y &= 
\begin{cases}
  \ttrue & \text{if }x = y\\
  \tfalse & \text{otherwise}
\end{cases}
&
\fname{eq}'\<y \<x &= 
\begin{cases}
  \ttrue & \text{if }x = y\\
  \tfalse & \text{otherwise}
\end{cases}
\end{align*}

Since $\tnil_\tbool = \tfalse$, for any $x : A$, there are finitely many $y : A$ (exactly one, in fact) such that $\fname{eq} \<x\<y \ne \tnil$. However, $\tnil_{A \to \tbool} = \fn x \tfalse$, so unless $A$ is finite there are infinitely many $y : A$ (all of them, in fact) such that $\fname{eq}'\<y \ne \tnil$.

For the same reason, point-preserving and finite maps do not commute: $P \lto (A \fto Q) \ncong A \fto (P \lto Q)$. It is slightly more inconvenient to construct a counterexample here, but not especially difficult. \todo{Is there a direction of this non-isomorphism that does hold? ie. a map from one side to the other?}

The consequence of this is \todo{that the rules for $\to$ and $\lto$ introduction have to have empty $\O$ contexts.}


\noindent
\todo{\textsc{problems \& todos}}
\begin{enumerate}
\item Can't define $\fname{or} : \tbool \x \tbool \lto \tbool$ within the language! I'm not sure how much of an issue this is. For instance, $\fname{exists} : (A \fto \tbool) \lto \tbool$ almost certainly needs to be primitive. And any commutative monoid $P$ where the point is the monoid's identity element should have methods $(\oplus) : P \times P \lto P$ and $\fname{sum} : (A \fto P) \lto P$; indeed, ``commutative monoid'' is essentially a typeclass with these two methods.

  (Q: In general, does $P \times P \lto P$ give rise to $(A \fto P) \lto P$ and/or vice-versa? A: There's no guarantee $P \times P \lto P$ is commutative. However, $(A \fto P) \lto P$ should give rise to $P \x P \lto P$ because $P \x P \lto (1 + 1) \fto P$.)

\item Can't express $\fname{forall} : (A \fto \tbool) \lto (A \to \tbool) \lto \tbool$, for two reasons:
  \begin{enumerate}
  \item $A \to \tbool$ isn't recognized as a pointed type.
    Could `fix' this by adding $P \bnfeq A \to P$, however...
  \item We still can't give proper intro/elim rules for it because it would require putting \emph{set} variables \emph{after} the linear context $\Delta$. Solution: maybe we need an ordered context which can mix set \& pointed variables? Or a sequence of alternating set/pointed/fin.sup contexts?
  \end{enumerate}
\end{enumerate}

\noindent One way to perhaps solve (1-2) is to stop pussyfooting about with pointed types and use commutative monoids instead. But then tensor product becomes unruly (it's no longer a quotient of the direct product); the ``maybe'' type $\tmaybe A$ isn't a commutative monoid; and perhaps other complexities creep in.

\begin{enumerate}
\item Think about what sideways information passing does to query planning.

  Sometimes it's simple, eg $(\fn{x} f\<x \tand x > 17)$ where $f : A \fto \tbool$.

\item Explain why we need $\Omega=\emptycx$ in ${\lto}\,\textsc{i}$.
\item Explain/justify the implicit duplication (turning $\D_1 \cup \D_2 \lto \D_1 \ox \D_2$) in the semantics of ${\lto}\,\textsc{e}$ and ${\ox}\,\textsc{i}$.

\item Why am I working with $\J t P \G \D \O$ as $\G \to \D \lto \O \fto P$ instead of putting the linear arguments after the f.s. ones, $\G \to \O \fto (\D \lto P)$?
  Or do I want both and need an ordered stack of contexts?

\item \strong{More example programs!} Ones which \emph{use} the $\D$ linear context in pattern matching / in combination with sideways information passing.
\end{enumerate}


\end{document}
